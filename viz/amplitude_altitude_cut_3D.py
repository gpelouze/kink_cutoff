#!/usr/bin/env python3


''' Plot the amplitude of oscillation as a function of the position along the
loop, from files written by CutZAnalysis.
'''


import argparse
import os
import re
import sys

import astropy.units as u
import numpy as np
import pyPLUTOplus as ppp
import papy.plot
import scipy.optimize as sopt

import matplotlib as mpl
import matplotlib.pyplot as plt
import etframes

from importlib import reload
import plot_tools as pt
reload(pt)
import analysis_tools as at
reload(at)


if __name__ == '__main__':

    p = argparse.ArgumentParser()
    p.add_argument('ini_dir',
                   help='directory containing pluto.ini')
    p.add_argument('--data-dir', default='./output',
                   help='value of output_dir from pluto.ini')
    p.add_argument('--cut-name', default='cut_center',
                   help='name of filenames generated by CutZAnalysis')
    p.add_argument('--no-reload', action='store_true',
                   help="don't load the data (for use with %run -i in IPython)")
    p.add_argument('--z0-eg', type=float, default=None,
                   help='plot amplitude determination example for the given z0')
    p.add_argument('--plot-max', action='store_true',
                   help='plot amplitude determined with max |v|')
    args = p.parse_args()

    pdf_metadata = {'Creator': ' '.join(sys.argv)}

    if not args.no_reload:
        dc = at.CutZDataset(
            args.ini_dir,
            args.cut_name,
            data_dir=args.data_dir,
            )

    dc.list['t'] -= dc.list['t'].min()
    vx1 = dc['vx1'] * u.Q(dc.units.velocity, 'cm s-1').to('km s-1')

    # max amplitude
    ampl_max = np.max(np.abs(vx1), axis=0)
    # fit sine amplitude
    vx1_fit = np.full_like(vx1, np.nan)
    ampl_fit = np.full_like(ampl_max, np.nan)
    P_fit = np.full_like(ampl_max.value, np.nan) * u.s
    def fit_func(t, A, w, p):
        return A * np.sin(w*t + p)
    P_driver = float(dc.ini['Parameters']['driver_p'])
    p0 = [5, 2*np.pi/P_driver, 0]
    for iz, this_vx1 in enumerate(vx1.T):  # loop over z cells
        popt, pcov = sopt.curve_fit(fit_func, dc.t_cgs.value, this_vx1.value, p0=p0)
        vx1_fit[:, iz] = fit_func(dc.t_cgs.value, *popt) * vx1.unit
        ampl_fit[iz] = np.abs(popt[0] * vx1.unit)
        P_fit[iz] = np.abs(2*np.pi/popt[1] * dc.t_cgs.unit)
    Pdelta_fit = (P_fit.to('s').value - P_driver) / P_driver

    plt.clf()
    plt.plot(dc.x3, ampl_fit[::-1].to('km s-1'), 'k-', label='fit')
    if args.plot_max:
        plt.plot(dc.x3, ampl_max[::-1].to('km s-1'), 'k--', label='max')
    plt.xlabel(f'Altitude [{dc.x3.unit}]')
    plt.ylabel(f'Velocity amplitude [km s⁻¹]')
    if args.plot_max:
        plt.legend()
    etframes.add_range_frame(plt.gca(), xbounds=[0, 100], ybounds=[2, None])
    plt.savefig(f'{dc.plot_dir}/ampl_alt_cut_vx1_ampl.pdf', metadata=pdf_metadata)

    plt.clf()
    plt.plot(dc.x3, P_fit[::-1].to('s'), 'k-')
    plt.xlabel(f'Altitude [{dc.x3.unit}]')
    plt.ylabel(f'Velocity period [s]')
    etframes.add_range_frame(plt.gca(), xbounds=[0, 100], ybounds=[2, None])
    plt.savefig(f'{dc.plot_dir}/ampl_alt_cut_vx1_P.pdf', metadata=pdf_metadata)

    plt.clf()
    plt.plot(dc.x3, Pdelta_fit[::-1] * 100, 'k-')
    plt.xlabel(f'Altitude [{dc.x3.unit}]')
    plt.ylabel(f'Relative period variation [%]')
    etframes.add_range_frame(plt.gca(), xbounds=[0, 100])
    plt.savefig(f'{dc.plot_dir}/ampl_alt_cut_vx1_Pdelta.pdf', metadata=pdf_metadata)

    if args.z0_eg:
        iz0 = np.argmin(np.abs(dc.x3.to('Mm').value - args.z0_eg))
        plt.clf()
        plt.plot(dc.t_cgs, vx1[:, iz0], 'C1-', lw=2, label='simu')
        plt.plot(dc.t_cgs, vx1_fit[:, iz0], 'k-', lw=1, label='fit')
        plt.xlabel(f'Altitude [{dc.x3.unit}]')
        plt.ylabel(f'Velocity amplitude [{vx1.unit}]')
        plt.legend()
        plt.savefig(f'{dc.plot_dir}/ampl_alt_cut_vx1_ampl_eg.pdf', metadata=pdf_metadata)

    # Save data for common plot
    np.savez(
        f'{dc.plot_dir}/ampl_alt_data.npz',
        ini_dir=dc.ini_dir,
        driver_p=float(dc.ini['Parameters'].get('driver_p')),
        vrw_x_max_layer=float(dc.ini['Parameters'].get('vrw_x_max_layer')),
        t=dc.t_cgs.to('s').value,
        z=dc.x3.to('Mm').value,
        vx1=vx1,
        vx1_fit=vx1_fit,
        ampl_max=ampl_max,
        ampl_fit=ampl_fit,
        P_fit=P_fit,
        )
